<?xml version="1.0" encoding="UTF-8"?>
<launch>
   <!-- args: -->
   <arg name="robot_name" default="kuka"/>
   <arg name="robot_x_pos" default="0"/>
   <arg name="robot_y_pos" default="0"/>
   <arg name="robot_z_pos" default="0"/>


   <!-- use additional tools: -->
   <arg name="start_rviz" default="False"/>
   <arg name="start_plotjuggler" default="False"/>
   <arg name="start_rqt_gui" default="False"/>

   <!-- start Gazebo -->
   <include file="$(find gazebo_ros)/launch/empty_world.launch">
      <arg name="world_name" value="$(find kuka_kr5_gazebo)/worlds/empty.world" />
      <arg name="paused" value="True" />
      <arg name="use_sim_time" value="True" /> <!-- Tells ROS nodes asking for time to get the Gazebo-published simulation time, published over the ROS topic /clock (default true) -->
      <arg name="gui" value="True" />
      <arg name="headless" value="False" />
      <arg name="debug" value="False" />
      <!-- If you wanna use a different gazebo physics engine: -->
      <!-- <arg name="verbose" default="-e bullet"/> -->
      <!-- rosservice call unpause gazebo: rosservice call gazebo/unpause_physics -->
   </include>

   <group ns="$(arg robot_name)">

      <!-- load robot_description (kuka with plate) -->
      <include file="$(find kuka_manipulator_description)/launch/load_kr5.launch">
         <arg name="robot_name" value="$(arg robot_name)" />
      </include>

      <!-- robot spawner -->
      <!-- Run a python script to the send a service call to gazebo_ros to spawn a URDF robot -->
      <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model" args="-urdf -model $(arg robot_name) -param robot_description -x $(arg robot_x_pos)   -y $(arg robot_y_pos) -z $(arg robot_z_pos)" />

      <!-- load controllers -->
      <group ns="joints"> </group>

      <include file="$(find kuka_kr5_control)/launch/start_joint_state_controller.launch">
                 <arg name="publish_rate" value="100"/>
       </include>

      <!-- tf publisher convert joint states to TF transforms for rviz, etc -->
      <remap from="joint_states" to="joints/joint_states" />
      <node pkg="robot_state_publisher" type="robot_state_publisher" name="robot_state_publisher" output="screen" respawn="false">
         <param name="tf_prefix" type="string" value="$(arg robot_name)" if="False" />
      </node>
   </group>

    <!-- transform ground truth pose to tf -> for world transformation required for rviz tf -->
    <node name="odom_to_tf_robot" pkg="message_to_tf" type="message_to_tf">
      <param name="odometry_topic" type="string" value="/gazebo/$(arg robot_name)/odom" />
      <param name="child_frame_id" type="string" value="footprint" />
    </node>

<!-- start our controller: for the ballbot: or the drive controller
<include file="$(find bb_control)/launch/start_control_node.launch">
  <arg name="controller_type" value="$(arg controller_type)" />
  <arg name="motors_controller_type" value="$(arg motors_controller_type)" />
</include> -->

<!-- start additional tool's: -->
<group if="$(arg start_rviz)">
  <node pkg="rviz" type="rviz" name="rviz" args="-d $(find kuka_kr5_gazebo)/config/model.rviz"  required="true"/>
</group>

<group if="$(arg start_plotjuggler)"> <!--  -l $(find ballbot_description)/rviz/plot_juggler_layout.xml -->
 <node pkg="plotjuggler" type="PlotJuggler" name="my_plot_Juggler" args="" />
</group>

<group if="$(arg start_rqt_gui)">   <!-- start rqt: rosrun rqt_gui rqt_gui   if starts to fast just click blue refresh button! -->
  <node name="ballbot_rqt" pkg="rqt_gui" type="rqt_gui" respawn="false" output="screen" args="-perspective-file $(find kuka_kr5_gazebo)/config/bb_rqt.perspective"/>
</group>

</launch>
